
//implemented in the bridges 2 supercomputer
//new parallel minimax class

public class ParallelMiniMax {
    private int x_wins;
    private int o_wins;
    private float[][] ratio = new float[3][3];
    private int[] bestMove = new int[4];
    
    // parallelizing the first 1 levels gives better performance
    // Going deeper creates too much overhead with thread management
    private static final int PARALLEL_DEPTH_LIMIT = 1; 
    
    public ParallelMiniMax() {
        this.x_wins = 0;
        this.o_wins = 0;
        // Initialize ratio matrix to zeros
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 3; j++){
                ratio[i][j] = 0;
            }
        }
    }

    //same eval functions as normal MiniMax in between

    // Main minimax with parallel processing calls parallel at depth 1, and recursive past


    // Parallel search using thread pool - distributes move evaluation across multiple threads
    private float parallelSearch(BigBoard board, int depth, boolean isMaximizing, int originalDepth, float alpha, float beta, TranspositionTable map, int currentLevel) {
        
        ArrayList<int[]> legalMoves = board.getAvailableMoves();
        
        // prevent more threads than cores or moves to evaluate
        int numThreads = Math.min(Runtime.getRuntime().availableProcessors(), legalMoves.size());
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        
        List<Future<MoveResult>> futures = new ArrayList<>();
        
        try {
            // Submit each move as a separate task
            for (int[] move : legalMoves) {
                Future<MoveResult> future = executor.submit(new MoveEvaluator(
                    deepCopy(board), move, depth, isMaximizing, originalDepth, 
                    alpha, beta, map, currentLevel
                ));
                futures.add(future);
            }
            
            // Wait for all evaluations to complete and find the best one
            float bestValue = isMaximizing ? -Float.MAX_VALUE : Float.MAX_VALUE;
            int[] currentBestMove = null;
            
            for (int i = 0; i < futures.size(); i++) {
                try {
                    MoveResult result = futures.get(i).get();
                    
                    if (isMaximizing) {
                        if (result.value > bestValue) {
                            bestValue = result.value;
                            currentBestMove = result.move;
                            // DEBUG output to track best move changes
                            //System.out.println("New best maximizing move: " + Arrays.toString(result.move) + " value: " + result.value);
                        }
                    } else {
                        if (result.value < bestValue) {
                            bestValue = result.value;
                            currentBestMove = result.move;
                        }
                    }
                    
                    // Store the best move if we're at the root level
                    if (depth == originalDepth && currentBestMove != null) {
                        bestMove = currentBestMove.clone();
                    }
                    
                } catch (Exception e) {
                    System.err.println("ERROR: Thread execution failed: " + e.getMessage());
                    e.printStackTrace();
                }
            }
            
            return bestValue;
            
        } finally {
            executor.shutdown(); // Clean up thread pool
        }
    }

    // Regular minimax for deeper levels - avoids thread creation overhead                

                this.value = value;
        }
    }

    // Main entry point - call this to get the best move using parallel processing
    public int[] findBestMoveParallel(BigBoard board, int depth, TranspositionTable map) {
        bestMove = null;
        
        long startTime = System.nanoTime();
        parallelMiniMax(board, depth, true, depth, -Float.MAX_VALUE, Float.MAX_VALUE, map, 0);
        long endTime = System.nanoTime();
        
        System.out.println("Parallel minimax completed in " + ((endTime - startTime) / 1_000_000.0) + " ms");
        
        int[] result = bestMove;
        bestMove = null; // Clean up
        return result;
    }

    // Deep copy methods - necessary to avoid race conditions in parallel execution
}











